[[https://travis-ci.org/bendudson/py4cl][https://travis-ci.org/bendudson/py4cl.svg?branch=master]]

* Introduction

Py4CL is a bridge between Common Lisp and Python, which enables Common
Lisp to interact with Python code. It uses streams to communicate with
a separate python process, the approach taken by [[https://github.com/marcoheisig/cl4py][cl4py]]. This is
different to the CFFI approach used by [[https://github.com/pinterface/burgled-batteries][burgled-batteries]], but has the
same goal. 

** Installing

Depends on:

 - Currently tested with SBCL, CCL and ECL (after 2016-09-06). CLISP
   doesn't (yet) have =uiop:launch-program=.
 - ASDF3 version 3.2.0 (Jan 2017) or later, as =uiop:launch-program=
   is used to run and communicate with python asyncronously.
 - [[https://common-lisp.net/project/trivial-garbage/][Trivial-garbage]], available through Quicklisp.
 - Python 2 or 3
 - (optional) The [[http://www.numpy.org/][NumPy]] python library for multidimensional arrays

Clone this repository into =~/quicklisp/local-projects/= or other
location where it can be found by ASDF:
#+BEGIN_SRC bash
$ git clone https://github.com/bendudson/py4cl.git
#+END_SRC

then load into Lisp with
#+BEGIN_SRC lisp
(ql:quickload :py4cl)
#+END_SRC

** Tests

Tests use [[https://github.com/tgutu/clunit][clunit]], and run on [[https://travis-ci.org/][Travis]] using [[https://github.com/luismbo/cl-travis][cl-travis]]. Most development
is done under Arch linux with SBCL and Python3. To run the tests
yourself:
#+BEGIN_SRC lisp
(asdf:test-system :py4cl)
#+END_SRC
or
#+BEGIN_SRC lisp
(ql:quickload :py4cl/tests)
(py4cl/tests:run)
#+END_SRC

* Examples

Py4CL allows python modules to be imported as Lisp packages, python
functions to be called from lisp, and lisp functions called from
python. In the example below, [[https://www.scipy.org/][SciPy]]'s [[https://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.odeint.html][odeint]] function is used to
integrate ODEs defined by a Lisp function. The result is a Lisp array,
which is then plotted using the [[https://matplotlib.org/][matplotlib]] plotting library.

#+BEGIN_SRC lisp
(ql:quickload :py4cl)

(py4cl:import-module "numpy" :as "np")
(py4cl:import-module "scipy.integrate" :as "integrate")

;; Integrate some ODEs
(defparameter *data*
  (integrate:odeint 
   (lambda (y time) 
     (vector (aref y 1)       ; dy[0]/dt = y[1]
             (- (aref y 0)))) ; dy[1]/dt = -y[0]
   #(1.0 0.0)   ; Initial state
   (np:linspace 0.0 (* 2 pi) 20)))  ; Vector of times

; (array-dimensions *data*) => (20 2)

;; Make a plot, save and show it in a window
(py4cl:import-module "matplotlib.pyplot" :as "plt")

(plt:plot *data*)
(plt:xlabel "Time")
(plt:savefig "result.pdf")
(plt:show)
#+END_SRC

For more direct access to the python subprocess, =python-eval=
evaluates an expression, converting the result to a suitable lisp
type. Note that there are nicer, more lispy wrappers around this function,
described below, but they are mostly built on top of =python-eval=.

#+BEGIN_SRC lisp
(asdf:load-system "py4cl")

(py4cl:python-eval "[i**2 for i in range(5)]") ; => #(0 1 4 9 16)
#+END_SRC

#+RESULTS:
| 0 | 1 | 4 | 9 | 16 |

#+BEGIN_SRC lisp
(py4cl:python-eval "{'hello':'world', 'answer':42}") ; => #<HASH-TABLE :TEST EQUAL :COUNT 2>
#+END_SRC

#+RESULTS:
: #<HASH-TABLE :TEST EQUAL :COUNT 2 {10036F03F3}>

Data is passed between python and lisp as text. The python function
=lispify= converts values to a form which can be read by the lisp
reader; the lisp function =pythonize= outputs strings which can be
=eval='d in python. The following type conversions are done:

| Lisp type | Python type   |
|-----------+---------------|
| NIL       | None          |
| integer   | int           |
| ratio     | float         |
| real      | float         |
| complex   | complex float |
| string    | str           |
| hash map  | dict          |
| list      | tuple         |
| vector    | list          |
| array     | NumPy array   |
| symbol    | Symbol class  |
| function  | function      |

Note that python does not have all the numerical types which lisp has,
for example rational numbers or complex integers.

Because =python-eval= and =python-exec= evaluate strings as python
expressions, strings passed to them are not escaped or converted as
other types are. To pass a string to python as an argument, call =py4cl::pythonize=

#+BEGIN_SRC lisp
(let ((my-str "testing"))
  (py4cl:python-eval "len(" (py4cl::pythonize my-str) ")" ))
#+END_SRC

#+RESULTS:
: 7

If python objects cannot be converted into a lisp value, then they are
stored and a handle is returned to lisp. This handle can be used to
manipulate the object, and when it is garbage collected the python
object is also deleted (using the [[https://common-lisp.net/project/trivial-garbage/][trivial-garbage]] package).

#+BEGIN_SRC lisp
(destructuring-bind (fig ax) (plt:subplots)
  ;; fig is #S(PY4CL::PYTHON-OBJECT :TYPE "<class 'matplotlib.figure.Figure'>" :HANDLE 6)
  (py4cl:python-eval ax ".plot(" #(0 1 0 1) ")")
  (plt:show)) 
#+END_SRC

The python process can be explicitly started and stopped using
=python-start= and =python-stop=, but =py4cl= functions start python
automatically if needed by calling =python-start-if-not-alive=.

** Calling python functions

=python-call= can be used to pass arguments to any python callable, 
such as a function in a module:

#+BEGIN_SRC lisp
(py4cl:python-exec "import math")
(py4cl:python-call "math.sqrt" 42)
#+END_SRC

#+RESULTS:
: 6.4807405

or a lambda function:
#+BEGIN_SRC lisp
(py4cl:python-call "lambda x: 2*x" 21)
#+END_SRC

#+RESULTS:
: 42

Keywords are translated, with the symbol made lowercase:
#+BEGIN_SRC lisp
(py4cl:python-call "lambda a=0, b=1: a-b" :b 2 :a 1)
#+END_SRC

#+RESULTS:
: -1

** Calling python methods

Python methods on objects can be called by using the =python-method= function. The first argument
is the object (including strings, arrays, tuples); the second argument is either a string or a symbol
specifying the method, followed by any arguments:
#+BEGIN_SRC lisp
(py4cl:python-method "hello {0}" 'format "world") ; => "hello world"
#+END_SRC

#+RESULTS:
: hello world

#+BEGIN_SRC lisp
(py4cl:python-method '(1 2 3) '__len__) ; => 3
#+END_SRC

#+RESULTS:
: 3

** Chaining python methods

In python it is quite common to apply a chain of method calls, data
member access, and indexing operations to an object. To make this work
smoothly in Lisp, there is the =chain= macro (Thanks to @kat-co and
[[https://common-lisp.net/project/parenscript/reference.html][parenscript]] for the inspiration). This consists of a target object,
followed by a chain of operations to apply.  For example
#+BEGIN_SRC lisp
(py4cl:chain "hello {0}" (format "world") (capitalize)) ; => "Hello world"
#+END_SRC

#+RESULTS:
: Hello world

which is converted to python 
#+BEGIN_SRC python
return "hello {0}".format("world").capitalize()
#+END_SRC

#+RESULTS:
: Hello world

The only things which are treated specially by this macro are lists
and symbols at the top level. The first element of lists are treated as
python method names, top-level symbols are treated as data
members. Everything else is evaluated as lisp before being converted
to a python value.

If the first argument is a list, then it is assumed to be a python
function to be called; otherwise it is evaluated before converting to
a python value. For example
#+BEGIN_SRC lisp
(py4cl:chain (slice 3) stop)
#+END_SRC

#+RESULTS:
: 3

is converted to the python:
#+BEGIN_SRC python
return slice(3).stop
#+END_SRC

#+RESULTS:
: 3

Symbols as first argument, or arguments to python methods, are
evaluated, so the following works:
#+BEGIN_SRC lisp
(let ((format-str "hello {0}")
      (argument "world"))
 (py4cl:chain format-str (format argument))) ; => "hello world"
#+END_SRC

#+RESULTS:
: hello world

Arguments to methods are lisp, since only the top level forms in =chain= are treated specially:
#+BEGIN_SRC lisp
(py4cl:chain "result: {0}" (format (+ 1 2))) ; => "result: 3"
#+END_SRC

#+RESULTS:
: result: 3

Indexing with =[]= brackets is commonly used in python, which calls the =__getitem__= method.
This method can be called like any other method
#+BEGIN_SRC lisp
(py4cl:chain "hello" (__getitem__ 4)) ; => "o"
#+END_SRC

#+RESULTS:
: o

but since this is a common method an alias =[]= is supported:
#+BEGIN_SRC lisp
(py4cl:chain "hello" ([] 4)) ; => "o"
#+END_SRC

#+RESULTS:
: o

which is converted to the python
#+BEGIN_SRC python
return "hello"[4]
#+END_SRC

#+RESULTS:
: o

For simple cases where the index is a value like a number or string
(not a symbol or a list), the brackets can be omitted:
#+BEGIN_SRC lisp
(py4cl:chain "hello" 4) ; => "o"
#+END_SRC

#+RESULTS:
: o

Slicing can be done by calling the python =slice= function:
#+BEGIN_SRC lisp
(py4cl:chain "hello" ([] (py4cl:python-call "slice" 2 4)))  ; => "ll"
#+END_SRC

#+RESULTS:
: ll

which could be imported as a lisp function (see below):
#+BEGIN_SRC lisp
(py4cl:import-function "slice")
(py4cl:chain "hello" ([] (slice 2 4))) ; => "ll"
#+END_SRC

#+RESULTS:
: ll

This of course also works with multidimensional arrays:
#+BEGIN_SRC lisp
(py4cl:chain #2A((1 2 3) (4 5 6))  ([] 1 (slice 0 2)))  ;=> #(4 5)
#+END_SRC

#+RESULTS:
| 4 | 5 |

** Asynchronous python functions

One of the advantages of using streams to communicate with a separate
python process, is that the python and lisp processes can run at the
same time. =python-call-async= calls python but returns a closure
immediately. The python process continues running, and the result can
be retrieved by calling the returned closure. 

#+BEGIN_SRC lisp
(defparameter thunk (py4cl:python-call-async "lambda x: 2*x" 21))

(funcall thunk)  ; => 42
#+END_SRC

#+RESULTS:
: 42

If the function call requires callbacks to lisp, then these will only
be serviced when a =py4cl= function is called. In that case the python
function may not be able to finish until the thunk is called. This
should not result in deadlocks, because all =py4cl= functions can
service callbacks while waiting for a result.

** Importing functions

Python functions can be made available in Lisp by using =import-function=. By
default this makes a function which can take any number of arguments, and then
translates these into a call to the python function.
#+BEGIN_SRC lisp
(asdf:load-system "py4cl")

(py4cl:python-exec "import math")
(py4cl:import-function "math.sqrt")
(math.sqrt 42) ; => 6.4807405
#+END_SRC

#+RESULTS:
: 6.4807405

If a different symbol is needed in Lisp then the =:as= keyword can be
used with either a string or symbol:
#+BEGIN_SRC lisp
(py4cl:import-function "sum" :as "pysum")
(pysum '(1 2 3))  ; => 6
#+END_SRC

#+RESULTS:
: 6

This is implemented as a macro which defines a function which in turn calls =python-call=.

** Importing modules

Python modules can be imported as lisp packages using =import-module=.
For example, to import the [[https://matplotlib.org/][matplotlib]] plotting library, and make its functions
available in the package =PLT= from within Lisp:
#+BEGIN_SRC lisp :session import-example
(asdf:load-system "py4cl")
(py4cl:import-module "matplotlib.pyplot" :as "plt") ; Creates PLT package
#+END_SRC

#+RESULTS:
: T

This will also import it into the python process as the module =plt=, so that
=python-call= or =python-eval= can also make use of the =plt= module. 

Like =python-exec=, =python-call= and other similar functions, 
=import-module= starts python if it is not already running, so that
the available functions can be discovered.

The python docstrings are made available as Lisp function docstrings, so we can see them
using =describe=:
#+BEGIN_SRC  lisp :session import-example
(describe 'plt:plot)
#+END_SRC

Functions in the =PLT= package can be used to make simple plots:
#+BEGIN_SRC lisp :session import-example
(plt:plot #(1 2 3 2 1) :color "r")
(plt:show)
#+END_SRC

#+RESULTS:
: NIL

* Exporting a function to python

Lisp functions can be passed as arguments to =python-call= 
or imported functions:
#+BEGIN_SRC lisp
(py4cl:python-exec "from scipy.integrate import romberg")

(py4cl:python-call "romberg" 
                   (lambda (x) (/ (exp (- (* x x)))
                                  (sqrt pi)))
                   0.0 1.0) ; Range of integration
#+END_SRC

#+RESULTS:
: 0.4213504

Lisp functions can be made available to python code using =export-function=:
#+BEGIN_SRC lisp
(py4cl:python-exec "from scipy.integrate import romberg")

(py4cl:export-function (lambda (x) (/ (exp (- (* x x)))
                                      (sqrt pi))) "gaussian")

(py4cl:python-eval "romberg(gaussian, 0.0, 1.0)") ; => 0.4213504
#+END_SRC

#+RESULTS:
: 0.4213504

